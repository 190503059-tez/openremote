<!-- The style will load theme and polymer -->
<link rel="import" href="or-style.html">

<!-- Promise API polyfill on IE 11  -->
<script src="/static/3rdparty/es6-promise.js"></script>

<!-- Keycloak if it's available -->
<script src="/auth/js/keycloak.js"></script>

<dom-module id="or-app">

    <template>

        <style>
            :host {
                /* Hide the app by default */
                visibility: hidden;
            }

            /* TODO difficult but must have something on left side before ::
            #slot ::slotted(*) {
                color: var(--theme-lightgreen);
                background: var(--theme-black);
            }
            */

        </style>

        <template is="dom-if" if="[[error]]">
            <div style="padding:1em;">
                <h1 style="color: var(--theme-darkgrey);">Error starting OpenRemote application</h1>
                <h5><span>[[error]]</span></h5>
                <h3>[[defaultErrorMessage]]</h3>
            </div>
        </template>

        <slot id="slot"></slot>

    </template>

    <script>

        class OpenRemoteViewComponent extends Polymer.Element {
            static get properties() {
                return {
                    widgetStyle: {
                        type: openremote.style.WidgetStyle,
                        value: () => {
                            return openremote.WIDGET_STYLE
                        }
                    }
                }
            }

            ready() {
                super.ready();

                // View component should flex and its children should be in a flexbox vertical layout by default
                this.shadowRoot.host.classList.add("flex", "layout", "vertical");

                // View component is hidden by default, subclass decides when it's ready
                this.hideComponent();
            }

            showComponent() {
                Polymer.RenderStatus.afterNextRender(this, function () {
                    this.shadowRoot.host.style.visibility = "visible";
                });
            }

            hideComponent() {
                Polymer.RenderStatus.afterNextRender(this, function () {
                    this.shadowRoot.host.style.visibility = "hidden";
                });
            }

            i18n(presenter, key) {
                return presenter ? presenter.messages()[key]() : "";
            }

            icon(name) {
                return "fa fa-" + name;
            }

        }

        /**
         * Singleton per window/document, registers itself as window.openremote.INSTANCE.
         */
        class OpenRemoteApp extends Polymer.Element {

            static get is() {
                return "or-app";
            }

            static get properties() {
                return {
                    /**
                     * True if this app should enforce an authenticated user.
                     */
                    login: Boolean,

                    /**
                     * Name of the OpenRemote user who is authenticated, available for two-way binding.
                     */
                    user: {
                        type: String,
                        notify: true
                    },

                    /**
                     * Name of the OpenRemote tenant this app wants to connect to
                     * and possibly login and authenticate with. Tenant can be overridden with an
                     * attribute, otherwise try to get it from URL path, first segment.
                     */
                    tenant: {
                        type: String,
                        value: () => {
                            return window.location.pathname.split('/')[1];
                        }
                    },

                    /**
                     *  Time to wait in seconds before we are sure the service is
                     *  disconnected and not just silent.
                     */
                    timeout: {
                        type: Number
                    },

                    /**
                     * CONNECTED, DISCONNECTED, WAITING, available for two-way binding.
                     */
                    status: {
                        type: String,
                        notify: true,
                    },

                    /**
                     * The current error state, if any.
                     */
                    error: {
                        type: String,
                        observer: "onAppError"
                    },

                    /**
                     * The message that should be shown to the user, before the error state.
                     */
                    defaultErrorMessage: {
                        type: String,
                        value: function () {
                            return "Service not available, please try again later.";
                        }
                    },

                    /**
                     * Produces promises to load JS, CSS, HTML, IMG resources.
                     */
                    load: {
                        type: Object,
                        value: function () {
                            function _load(tag, rel) {
                                return function (url) {
                                    return new Promise(function (resolve, reject) {
                                        var element = window.document.createElement(tag);
                                        // Append loading tags to the body
                                        var parent = 'body';
                                        var attr = 'src';

                                        // Important success and error for the promise
                                        element.onload = function () {
                                            resolve(url);
                                        };
                                        element.onerror = function () {
                                            reject("Loading failed as '" + tag + "': " + url);
                                        };

                                        switch (tag) {
                                            case 'script':
                                                element.async = false;
                                                break;
                                            case 'link':
                                                element.rel = rel;
                                                attr = 'href';
                                                break;
                                        }

                                        element[attr] = url;
                                        window.document[parent].appendChild(element);
                                    });
                                };
                            }

                            return {
                                css: _load("link", "stylesheet"),
                                import: _load("link", "import"),
                                js: _load("script"),
                                img: _load("img")
                            }
                        }
                    },

                    /**
                     * True if this app runs on an Apple iOS device.
                     */
                    shellApple: {
                        type: Boolean,
                        value: function () {
                            return navigator.platform.substr(0, 2) === 'iP' && window.webkit && window.webkit.messageHandlers;
                        }
                    },

                    /**
                     * True if this app runs on an Android device.
                     */
                    shellAndroid: {
                        type: Boolean,
                        value: function () {
                            return !!window.MobileInterface;
                        }
                    },

                    /**
                     * True if the native (mobile) app shell is available.
                     */
                    shellNative: {
                        type: Boolean,
                        computed: "computeShellNative(shellApple, shellAndroid)"
                    },

                    /**
                     * Defined when Keycloak is available and configured.
                     */
                    keycloak: {
                        type: Object,
                        computed: "computeKeycloak(tenant)"
                    },
                };
            }

            constructor() {
                super();

                // Hack the custom-style element into <head>
                let customStyle = document.createElement("custom-style");
                let style = document.createElement("style");
                style.setAttribute("include", "or-style");
                customStyle.appendChild(style);
                document.head.appendChild(customStyle);
            }

            ready() {
                super.ready();

                // This is a singleton for the window/main document
                if (window.openremote && window.openremote.INSTANCE) {
                    this.set("error", "An instance of &lt;or-app> is already registered on this window, please use only one per document.")
                    return;
                }
                // Register this as constant on window for GWT and others to access
                console.debug("Registering as window.openremote.INSTANCE (in native shell: " + this.shellNative + ")");
                window.openremote = {INSTANCE: this};

                // The app should flex and its children should be in a flexbox vertical layout
                this.shadowRoot.host.classList.add("flex", "layout", "vertical");

                /* TODO Bind stuff to children here?
                <link rel="import" href="../../bower_components/polymer/lib/utils/flattened-nodes-observer.html">

                this._observer = new Polymer.FlattenedNodesObserver(this.$.slot, (info) => {
                    this._processNewNodes(info.addedNodes);
                    this._processRemovedNodes(info.removedNodes);
                });

                _processNewNodes(e) {
                    console.log("### NEW NODES");
                    console.dir(e);
                }

                _processRemovedNodes(e) {
                    console.log("### REMOVED NODES");
                    console.dir(e);
                }

                this.$.slot.addEventListener("slotchange", e => {
                    console.log("### SLOT CHANGE, ASSIGNED NODES:");
                    console.dir(this.$.slot.assignedNodes({flatten: true}));
                });
                */

                if (this.login) {
                    this.startAuthentication();
                } else {
                    console.debug("No authentication required");
                    this.onAppInit();
                }
            }

            onAppInit() {
                // This is usually used to load other application resources which are not components, from the main document
                console.log("Application init");
                window.dispatchEvent(new CustomEvent("AppInit", {detail: {app: this}}));

                // Load service-generated REST API and GWT jsinterop components, in that order
                this.load.js("/jsapi")
                    .then(function () {
                        // When this is done, it will fire AppReady on window
                        return this.load.js("/static/gwt/App/App.nocache.js")
                    }.bind(this))
                    .catch(function (e) {
                        this.set("error", e);
                    }.bind(this));

                // Show app (note that loading and init might still happen asynchronously)
                this.showApp();
            }

            onAppError(error) {
                console.error("Application error: " + error);
                this.showApp();
            }

            showApp() {
                console.debug("Showing application");
                // The app is hidden by default, show it when it's ready
                this.shadowRoot.host.style.visibility = "visible";

                // Show the document body as late as possible (could be done earlier? only slow on FF)
                window.document.body.style.visibility = "visible";
            }

            computeShellNative(shellApple, shellAndroid) {
                return shellApple || shellAndroid
            }

            postNativeShellMessage(jsonMessage) {
                if (this.shellAndroid) {
                    return window.MobileInterface.postMessage(JSON.stringify(jsonMessage));
                }
                if (this.shellApple) {
                    console.debug(jsonMessage);
                    return window.webkit.messageHandlers.int.postMessage(jsonMessage);
                }
            }

            readNativeShellMessage(messageKey) {
                if (this.shellAndroid) {
                    return window.MobileInterface.getMessage(messageKey);
                }
                if (this.shellApple) {
                    return prompt(messageKey);
                }
            }

            startAuthentication() {
                console.log("Login required for tenant: " + this.tenant);
                if (this.keycloak) {
                    this.startKeycloakAuthentication()
                } else {
                    if (this.shellNative) {
                        window.alert("This OpenRemote service uses the basic identity provider, the application will not store credentials.")
                    }
                    this.startBasicAuthentication(
                        function () {
                            console.log("### SUCCESS");
                        }, function () {
                            console.log("### FAILURE");

                        }, function () {
                            console.log("### ERROR");
                        }
                    )
                }
            }

            /**
             * Called either manually by the user or when auth token refresh fails (refresh token invalid).
             */
            logout() {
                // If we never have to login, don't have to logout
                if (!this.login)
                    return;

                if (this.keycloak) {

                    // Clear native shell stored tokens
                    if (this.shellNative) {
                        this.postNativeShellMessage({type: 'token', data: {}});
                    }

                    // Navigate to start page on logout, drop the hash (also, Keycloak has a bug where it
                    // puts the hash into redirect_uri instead of redirect_fragment and then denies that
                    // this is a valid redirect URI, caused by https://github.com/keycloak/keycloak/pull/2188)
                    let options = {redirectUri: location.protocol + "//" + location.host + location.pathname}
                    console.log("Logging out with redirect URI: " + options.redirectUri);
                    this.keycloak.logout(options);

                } else {
                    // TODO Basic auth logout
                }
            }

            computeKeycloak(tenant) {
                // Check if Keycloak has been loaded
                if (window.Keycloak) {

                    // If we are logged in, logout when tenant changes
                    if (this.keycloak) {
                        this.logout();
                    }

                    let keycloakConfig = {
                        url: window.location.protocol + "//" + window.location.host + "/auth",
                        realm: tenant,
                        clientId: "openremote"
                    };
                    console.debug("On tenant change, Keycloak is available on: " + keycloakConfig.url);
                    return new Keycloak(keycloakConfig);
                } else {
                    console.debug("On tenant change, Keycloak not available");
                    return undefined;
                }
            }

            startKeycloakAuthentication() {
                console.debug("Keycloak authentication init");
                this.keycloak.init()
                    .success(
                        function (authenticated) {
                            if (authenticated) {
                                this.onKeycloakAuthSuccess()
                            } else {
                                this.onKeycloakAuthFailure()
                            }
                        }.bind(this)
                    )
                    .error(
                        function (e) {
                            this.set("error", e);
                        }.bind(this)
                    );
            }

            onKeycloakAuthSuccess() {
                console.log("Keycloak authentication successful");

                // Transfer tokens to native shell so they can be stored for future usage
                this.postNativeShellMessage({
                    type: 'token',
                    data: {
                        token: this.keycloak.token,
                        refreshToken: this.keycloak.refreshToken,
                        idToken: this.keycloak.idToken
                    }
                });

                // Update the access token in the background using the refresh token
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                }
                this.refreshInterval = setInterval(function () {

                    // Token must be good for X more seconds, should be half of Constants.ACCESS_TOKEN_LIFESPAN_SECONDS
                    let minValiditySeconds = 30;

                    this.keycloak.updateToken(minValiditySeconds)
                        .success(function (tokenRefreshed) {
                            console.debug("Access token checked, was refreshed from auth server: " + tokenRefreshed)
                        }.bind(this))
                        .error(function () {
                            console.warn("Access token refresh failed, session expired, logging out...");
                            this.logout();
                        }.bind(this));

                }.bind(this), 10000); // Check every 10 seconds

                this.set("user", this.keycloak.tokenParsed.preferred_username);

                // After authentication, the app is almost ready
                this.onAppInit();
            }

            onKeycloakAuthFailure() {
                console.log("Keycloak authentication failure");
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                }

                this.set("user", undefined);

                if (this.login) {
                    console.debug("Login required for tenant, trying again with scope offline_access: " + this.tenant);

                    // Get tokens from native shell to try again
                    let savedTokensString = this.readNativeShellMessage('token');
                    if (savedTokensString && savedTokensString.length > 0) {
                        console.debug("New login attempt with saved tokens from native shell: " + savedTokensString);
                        var savedTokens = JSON.parse(savedTokensString);
                        this.keycloak.token = savedTokens.token;
                        this.keycloak.refreshToken = savedTokens.refreshToken;
                        this.keycloak.idToken = savedTokens.idToken;
                    }

                    var options = {scope: "offline_access"};
                    console.log("Logging in with Keycloak");
                    this.keycloak.login(options);
                }
            }

            // TODO
            startBasicAuthentication(successCallback, failureCallback, errorCallback) {

            }
        }


        /* TODO IMPLEMENT THIS
            window.startBasicAuthentication = function (tenant, successCallback, failureCallback, errorCallback) {
                Promise.all([
                    load.js("/static/bower_components/webcomponentsjs/webcomponents-lite.min.js"),
                    load.import("/static/bower_components/iron-flex-layout/iron-flex-layout-classes.html"),
                    load.css("/static/bower_components/font-awesome/css/font-awesome.css"),

                    load.import("/static/css/style.html"),
                    load.import("/static/css/theme.html")
                ]).then(function () {
                    console.log("Resources loaded for basic authentication...");
                    setTimeout(handleLoadComplete, 0);
                    var authForm = renderBasicAuthForm();
                    document.body.appendChild(authForm);
                    // Override submit button handler
                    document.querySelector("#basicAuthForm [name='login']").onclick = function() {
                        var username = document.querySelector("#basicAuthForm [name='username']").value;
                        var password = document.querySelector("#basicAuthForm [name='password']").value;
                        performBasicAuthentication(
                            tenant,
                            username,
                            password,
                            function () {
                                console.log("Basic authentication successful...");
                                // Application can grab the credentials from window for its own requests
                                window.basicAuthUsername = username;
                                window.basicAuthPassword = password;
                                document.body.removeChild(authForm);
                                if (successCallback) {
                                    successCallback();
                                }
                            },
                            function() {
                                if (failureCallback) {
                                    failureCallback();
                                } else {
                                    console.log("Basic authentication failed, trying again");
                                    document.querySelector("#basicAuthForm .basicAuthMessage").style.display = "inherit";
                                    document.querySelector("#basicAuthForm .basicAuthMessageText").innerText = "Login failed, invalid username or password.";
                                }
                            },
                            errorCallback
                        );
                        return false;
                    }
                }).catch(errorCallback);
            };

            window.renderBasicAuthForm = function () {
                var authForm = document.createElement("div");
                authForm.classList.add("flex", "layout", "vertical");
                authForm.id = "basicAuthForm";
                authForm.innerHTML =
                    '<div class="flex layout vertical center-center">' +
                    '<div class="layout horizontal center-center" style="margin: 1em;">' +
                    '<a href="https://www.openremote.com/">' +
                    '<svg style="pointer-events: none; display: block; width: 4em; height:4em; margin-right: 0.4em;" viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet">' +
                    '<path fill="#C4D600" d="M11.93,21.851c-5.551,0-10.066-4.515-10.066-10.065h2.108c0,4.388,3.57,7.958,7.958,7.958 c4.387,0,7.958-3.57,7.958-7.958c0-4.388-3.57-7.958-7.958-7.958V1.72c5.55,0,10.066,4.517,10.066,10.066 C21.996,17.336,17.48,21.851,11.93,21.851L11.93,21.851z"/>' +
                    '<path fill="#4E9D2D" d="M10.406,19.088c-1.95-0.406-3.626-1.549-4.717-3.215s-1.469-3.66-1.062-5.61 c0.407-1.951,1.55-3.626,3.217-4.718c1.667-1.092,3.659-1.469,5.61-1.062c4.027,0.84,6.62,4.799,5.779,8.825l-2.063-0.429 c0.603-2.889-1.257-5.73-4.147-6.333c-1.4-0.292-2.829-0.022-4.025,0.762C7.802,8.091,6.982,9.293,6.69,10.693 c-0.291,1.398-0.021,2.828,0.762,4.024c0.783,1.196,1.985,2.016,3.385,2.307L10.406,19.088L10.406,19.088z"/>' +
                    '<path fill="#1D5632" d="M11.936,16.622c-0.082,0-0.164-0.001-0.245-0.004c-1.29-0.065-2.478-0.628-3.346-1.585 c-0.868-0.958-1.31-2.195-1.246-3.487l2.104,0.105c-0.036,0.728,0.214,1.427,0.704,1.967c0.488,0.54,1.16,0.858,1.888,0.894 c0.725,0.033,1.426-0.213,1.966-0.703c0.541-0.489,0.858-1.159,0.895-1.887c0.075-1.503-1.088-2.787-2.591-2.862l0.105-2.104 c2.664,0.132,4.724,2.406,4.592,5.07c-0.064,1.291-0.628,2.478-1.585,3.345C14.28,16.183,13.137,16.622,11.936,16.622L11.936,16.622 z"/>' +
                    '</svg>' +
                    '</a>' +
                    '<div class="layout vertical">' +
                    '<div class="or-HeadlineText" style="margin: 0; white-space: nowrap;"><span>Master</span></div>' +
                    '<div class="or-HeadlineSub" style="margin-left: 0.2em;">OpenRemote Login</div></div>' +
                    '</div>' +
                    '<div class="basicAuthMessage layout horizontal center or-FormMessages error" style="display: none;">' +
                    '<div class="or-MessagesIcon fa fa-warning"></div>' +
                    '<span class="basicAuthMessageText"></span>' +
                    '</div>' +
                    '<form class="layout vertical or-Form">' +
                    '<div class="layout horizontal center or-FormGroup">' +
                    '<div class="or-FormLabel">' +
                    '<label for="username">Username or email</label>' +
                    '</div>' +
                    '<div class="or-FormField">' +
                    '<input autocomplete="off" autocapitalize="off" class="or-FormControl or-FormInputText" name="username" value="" type="text" autofocus/>' +
                    '</div>' +
                    '</div>' +
                    '<div class="layout horizontal center or-FormGroup">' +
                    '<div class="or-FormLabel">' +
                    '<label for="password">Password</label>' +
                    '</div>' +
                    '<div class="or-FormField">' +
                    '<input class="or-FormControl or-FormInputText" name="password" type="password" autocomplete="off"/>' +
                    '</div>' +
                    '</div>' +
                    '<div class="layout horizontal center-center or-FormGroup">' +
                    '<div>' +
                    '<div>' +
                    '</div>' +
                    '</div>' +
                    '<div class="or-FormField">' +
                    '<input class="or-FormControl or-FormButtonPrimary or-PushButton" name="login" type="submit" value="Log in"/>' +
                    '</div>' +
                    '</div>' +
                    '</form>' +
                    '\</div>';
                return authForm;
            };

            window.performBasicAuthentication = function (tenant, username, password, successCallback, failureCallback, errorCallback) {
                try {
                    // Send a request with credentials to a resource that we know returns 200 or 401
                    var url = "/" + tenant + "/asset/user/current";

                    var x = new XMLHttpRequest();

                    // TODO You all suck
                    var isSafari = /constructor/i.test(window.HTMLElement) || (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })(!window['safari'] || safari.pushNotification);
                    var isChrome = !!window.chrome && !!window.chrome.webstore;
                    if (isSafari) {
                        // Must be async false or Safari will popup 401 dialog
                        x.open("GET", url, false);
                    } else if (isChrome) {
                        // Must set dummy URL username or Chrome will popup 401 dialog
                        x.open("GET", url, true, "dummy");
                    } else {
                        x.open("GET", url, true);
                    }

                    var credentials = "Basic " + btoa(username + ":" + password);
                    x.setRequestHeader("Authorization", credentials);

                    x.onreadystatechange = function () {
                        if (x.readyState > 3) {
                            if (successCallback && x.status === 200) {
                                successCallback();
                            } else if (failureCallback && x.status === 401) {
                                failureCallback();
                            } else if (errorCallback) {
                                errorCallback(x);
                            }
                        }
                    };
                    x.send()
                } catch (e) {
                    if (errorCallback) {
                        errorCallback(e);
                    }
                }
            };
         */

        // Upgrade immediately, so you can't use jsinterop here!
        customElements.define(OpenRemoteApp.is, OpenRemoteApp);

        // Set some globals when jsinterop components are ready
        window.addEventListener('AppReady', function () {
            openremote.WIDGET_STYLE = new openremote.style.WidgetStyle();
        });

        // Upgrade element and register its type when everything is ready
        function registerOpenRemoteElement(element, is, ...interopNames) {

            window.addEventListener('AppInit', function () {
                console.log("Setting type in global scope: " + is);
                // Sets openremote.foo.bar.MyType = element so we can have the type in GWT jsinterop
                let x = openremote;
                for (let i = 0; i < interopNames.length; i++) {
                    let name = interopNames[i];
                    if (!x[name]) {
                        x[name] = i === interopNames.length-1 ? element : {}
                    }
                    x = x[name];
                }
            });

            window.addEventListener('AppReady', function () {
                console.log("Upgrading element: " + is);
                customElements.define(is, element);
            });
        }
    </script>

</dom-module>