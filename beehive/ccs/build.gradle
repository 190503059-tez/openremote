apply plugin: "java"
apply plugin: "war"

dependencies {

    compile "org.openremote:or-commons:0.1.0"
    compile "org.openremote:or-object-model:0.2.1"

    compile "org.json:json:20090211"

    compile "net.sf.flexjson:flexjson:$flexjsonVersion"

    compile "org.slf4j:slf4j-api:$slf4jVersion"
    compile "ch.qos.logback:logback-classic:1.1.3"

    compile "org.glassfish.jersey.containers:jersey-container-servlet-core:$jerseyVersion"
    compile "javax.ws.rs:javax.ws.rs-api:$jaxrsVersion"

    compile "org.hibernate.javax.persistence:hibernate-jpa-2.1-api:1.0.0.Final"

    compile "org.hibernate:hibernate-core:$hibernateVersion"
    compile "org.hibernate:hibernate-entitymanager:$hibernateVersion"
    compile "org.hibernate:hibernate-c3p0:$hibernateVersion"

    compile "mysql:mysql-connector-java:$mysqlConnectorVersion"

    compile "commons-lang:commons-lang:$commonsLangVersion"
    compile "commons-codec:commons-codec:$commonsCodecVersion"
    compile "commons-dbcp:commons-dbcp:$commonsDbcpVersion"

    compile "org.springframework.security:spring-security-core:$springVersion"

    providedCompile "javax.servlet:javax.servlet-api:$servletVersion"

    testCompile "junit:junit:$junitVersion"
}

war {
    archiveName = 'ccs.war'

    // TODO: Replace with proper config system
    if (project.hasProperty("targetEnv")) {
        def targetEnvFolder = 'environments/' + targetEnv;
        if (new File(targetEnvFolder).exists()) {
            from(targetEnvFolder) {
                include '*.properties'
                include '*.xml'
                exclude 'web.xml'
                into ('WEB-INF/classes')
            }
            from(targetEnvFolder) {
                include 'web.xml'
                into ('WEB-INF')
            }
        } else {
            println "*** No configuration exists for target environment"
        }
    } else {
        println "*** No target environment defined"
    }
}

import com.bmuschko.gradle.docker.tasks.image.*

task buildImage(type: DockerBuildImage) {
    dependsOn war
    inputDir = projectDir
    dockerFile = file("$projectDir/Dockerfile")
    tag = dockerImageName
}

task pushImage(type: DockerPushImage) {
    dependsOn buildImage
    imageName = dockerImageName
}
