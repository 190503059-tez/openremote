<!-- The style will load theme and polymer -->
<link rel="import" href="or-style.html">

<!-- App services/dependencies -->
<link rel="import" href="or-shell-native.html">
<link rel="import" href="or-app-security.html">

<!-- Promise API polyfill on IE 11  -->
<script src="/static/3rdparty/es6-promise.js"></script>

<dom-module id="or-app">

    <template>

        <style include="or-style">
            #slots {
                /* Hide the slotted children by default */
                display: none;
            }

            #slots ::slotted(*) {
                /* TODO Example how to style slotted children
                border: 1px solid var(--theme-red);
                */
            }

        </style>

        <or-shell-native id="shellNative"></or-shell-native>

        <or-app-security id="appSecurity"
                         authenticated="{{authenticated}}"
                         login="{{login}}"
                         user="{{user}}"
                         tenant="{{tenant}}"
                         error="{{error}}"></or-app-security>

        <template is="dom-if" if="[[error]]">
            <div style="padding:1em;">
                <h1 style="color: var(--theme-darkgrey);">Error starting OpenRemote application</h1>
                <h5><span>[[error]]</span></h5>
                <h3>[[defaultErrorMessage]]</h3>
            </div>
        </template>

        <div id="slots" class="flex layout vertical">
            <slot id="slot"></slot>
        </div>

    </template>

    <script>

        class OpenRemoteViewComponent extends Polymer.Element {
            static get properties() {
                return {
                    widgetStyle: {
                        type: openremote.style.WidgetStyle,
                        value: () => {
                            return openremote.WIDGET_STYLE
                        }
                    }
                }
            }

            ready() {
                super.ready();

                // View component should flex and its children should be in a flexbox vertical layout by default
                this.shadowRoot.host.classList.add("flex", "layout", "vertical");

                // View component is hidden by default, subclass decides when it's ready
                this.hideComponent();
            }

            showComponent() {
                this.shadowRoot.host.style.visibility = "visible";
            }

            hideComponent() {
                this.shadowRoot.host.style.visibility = "hidden";
            }

            i18n(presenter, key) {
                return presenter ? presenter.messages()[key]() : "";
            }

            icon(name) {
                return "fa fa-" + name;
            }

        }

        /**
         * Singleton per window/document, registers itself as window.openremote.INSTANCE.
         */
        class OpenRemoteApp extends Polymer.Element {

            static get is() {
                return "or-app";
            }

            static get properties() {
                return {
                    /**
                     * True if this app should enforce an authenticated user.
                     */
                    login: Boolean,

                    /**
                     * Name of the OpenRemote tenant this app wants to connect to
                     * and possibly login and authenticate with. Tenant can be overridden with an
                     * attribute, otherwise try to get it from URL path, first segment.
                     */
                    tenant: String,

                    /**
                     * Whether the user is authenticated.
                     */
                    authenticated: {
                        type: Boolean,
                        notify: true,
                        reflectToAttribute: true,
                        observer: "onAuthenticated"
                    },

                    /**
                     * Name of the OpenRemote user to authenticate, available for two-way binding.
                     */
                    user: {
                        type: String,
                        notify: true,
                        reflectToAttribute: true
                    },

                    /**
                     *  Time to wait in seconds before we are sure the service is
                     *  disconnected and not just silent.
                     */
                    timeout: {
                        type: Number
                    },

                    /**
                     * CONNECTED, DISCONNECTED, WAITING, available for two-way binding.
                     */
                    status: {
                        type: String,
                        notify: true,
                    },

                    /**
                     * The current error state, if any.
                     */
                    error: {
                        type: String,
                        observer: "onAppError"
                    },

                    /**
                     * The message that should be shown to the user, before the error state.
                     */
                    defaultErrorMessage: {
                        type: String,
                        value: function () {
                            return "Service not available, please try again later.";
                        }
                    },

                    /**
                     * Produces promises to load JS, CSS, HTML, IMG resources.
                     */
                    load: {
                        type: Object,
                        value: function () {
                            function _load(tag, rel) {
                                return function (url) {
                                    return new Promise(function (resolve, reject) {
                                        var element = window.document.createElement(tag);
                                        // Append loading tags to the body
                                        var parent = 'body';
                                        var attr = 'src';

                                        // Important success and error for the promise
                                        element.onload = function () {
                                            resolve(url);
                                        };
                                        element.onerror = function () {
                                            reject("Loading failed as '" + tag + "': " + url);
                                        };

                                        switch (tag) {
                                            case 'script':
                                                element.async = false;
                                                break;
                                            case 'link':
                                                element.rel = rel;
                                                attr = 'href';
                                                break;
                                        }

                                        element[attr] = url;
                                        window.document[parent].appendChild(element);
                                    });
                                };
                            }

                            return {
                                css: _load("link", "stylesheet"),
                                import: _load("link", "import"),
                                js: _load("script"),
                                img: _load("img")
                            }
                        }
                    }
                };
            }

            constructor() {
                super();

                // Hack the custom-style element into <head>
                let customStyle = document.createElement("custom-style");
                let style = document.createElement("style");
                style.setAttribute("include", "or-style");
                customStyle.appendChild(style);
                document.head.appendChild(customStyle);
            }

            ready() {
                super.ready();

                // This is a singleton for the window/main document
                if (window.openremote && window.openremote.INSTANCE) {
                    this.set("error", "An instance of &lt;or-app> is already registered on this window, please use only one per document.")
                    return;
                }
                // Register this as constant on window for GWT and others to access
                console.debug("Registering as window.openremote.INSTANCE");
                window.openremote = {INSTANCE: this};

                // The app should flex and its children should be in a flexbox vertical layout
                this.shadowRoot.host.classList.add("flex", "layout", "vertical");

                /* TODO Bind stuff to children here?
                this._observer = new Polymer.FlattenedNodesObserver(this.$.slot, (info) => {
                    this._processNewNodes(info.addedNodes);
                    this._processRemovedNodes(info.removedNodes);
                });

                _processNewNodes(e) {
                    console.log("### NEW NODES");
                    console.dir(e);
                }

                _processRemovedNodes(e) {
                    console.log("### REMOVED NODES");
                    console.dir(e);
                }
                */
                /*
                this.$.slot.addEventListener("slotchange", e => {
                    console.log("### SLOT CHANGE, ASSIGNED NODES:");
                    console.dir(this.$.slot.assignedNodes({flatten: false}));
                    this.$.slot.assignedNodes({flatten: false}).forEach((node) => {
                        // Bind something to native elements?
                    })
                });
                */

                if (this.login) {
                    this.$.appSecurity.set("shellNative", this.$.shellNative);
                    this.$.appSecurity.startAuthentication();
                } else {
                    console.debug("No authentication required");
                    this.onAppInit();
                }
            }

            onAuthenticated(authenticated) {
                if (authenticated) {
                    console.debug("User authenticated: " + this.user);
                    this.onAppInit();
                }
            }

            logout() {
                if (this.$.appSecurity) {
                    this.$.appSecurity.logout();
                }
            }

            onAppInit() {
                // This is usually used to load other application resources which are not components, from the main document
                console.log("Application init");
                window.dispatchEvent(new CustomEvent("AppInit", {detail: {app: this}}));

                // Load service-generated REST API and GWT jsinterop components, in that order
                this.load.js("/jsapi")
                    .then( () => {
                        // When this is done, it will fire AppReady on window
                        return this.load.js("/static/gwt/App/App.nocache.js")
                    })
                    .catch((e) => {
                        this.set("error", e);
                    });
            }

            onAppError(error) {
                console.error("Application error, disabling app: " + error);

                // Remove all slotted children, effectively disabling the app
                this.$.slot.assignedNodes({flatten: false}).forEach((node) => {
                    node.parentElement.removeChild(node);
                })

                // Hide the slots
                this.$.slots.style.display = "none";

                // Show the document body
                window.document.body.style.visibility = "visible";
            }

            showApp() {
                console.debug("Showing application");

                // The slotted children are hidden by default (this will set display: flex)
                this.$.slots.style.display = "inherit";

                // TODO Safari bug, this will trigger another repaint, the first stops in some weird half-rendered state
                this.$.slots.style.webkitTransform = 'scale(1)';

                // Show the document body as late as possible
                window.document.body.style.visibility = "visible";
            }

            getAppSecurity() {
                return this.$.appSecurity;
            }
        }

        // Upgrade immediately, so you can't use jsinterop here!
        customElements.define(OpenRemoteApp.is, OpenRemoteApp);

        // Set some globals when jsinterop components are ready
        window.addEventListener('AppReady', function () {

            // Show the app when it's ready
            openremote.INSTANCE.showApp();

            openremote.WIDGET_STYLE = new openremote.style.WidgetStyle();
        });

        // Upgrade element and register its type when everything is ready
        function registerOpenRemoteElement(element, is, ...interopNames) {

            window.addEventListener('AppInit', function () {
                console.log("Setting type in global scope: " + is);
                // Sets openremote.foo.bar.MyType = element so we can have the type in GWT jsinterop
                let x = openremote;
                for (let i = 0; i < interopNames.length; i++) {
                    let name = interopNames[i];
                    if (!x[name]) {
                        x[name] = i === interopNames.length - 1 ? element : {}
                    }
                    x = x[name];
                }
            });

            window.addEventListener('AppReady', function () {
                console.log("Upgrading element: " + is);
                customElements.define(is, element);
            });
        }
    </script>

</dom-module>