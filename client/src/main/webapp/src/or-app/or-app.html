<!-- The style will load theme and polymer -->
<link rel="import" href="or-style.html">

<!-- App services/dependencies -->
<link rel="import" href="or-shell-native.html">
<link rel="import" href="or-app-security.html">

<!-- Promise API polyfill on IE 11  -->
<script src="/static/3rdparty/es6-promise.js"></script>

<dom-module id="or-app">

    <template>

        <style include="or-style">
            #slots {
                /* Hide the slotted children by default */
                display: none;
            }

            #slots ::slotted(*) {
                /* TODO Example how to style slotted children
                border: 1px solid var(--theme-red);
                */
            }

        </style>

        <or-shell-native id="shellNative"></or-shell-native>

        <or-app-security id="appSecurity"
                         login="{{login}}"
                         realm="{{tenantRealm}}"
                         authenticated="{{authenticated}}"
                         user="{{user}}"
                         error="{{error}}"></or-app-security>

        <template is="dom-if" if="[[error]]">
            <div style="padding:1em;">
                <h1 style="color: var(--theme-darkgrey);">[[defaultErrorMessage]]</h1>
                <h5><span>[[error]]</span></h5>
            </div>
        </template>

        <div id="slots" class="flex layout vertical">
            <slot id="slot"></slot>
        </div>

    </template>

    <script>

        class OpenRemoteViewComponent extends Polymer.Element {
            static get properties() {
                return {
                    widgetStyle: {
                        type: openremote.style.WidgetStyle,
                        value: () => {
                            return openremote.WIDGET_STYLE
                        }
                    }
                }
            }

            ready() {
                super.ready();

                // View component should flex and its children should be in a flexbox vertical layout by default
                this.shadowRoot.host.classList.add("flex", "layout", "vertical");

                // View component is hidden by default, subclass decides when it's ready
                this.hideComponent();
            }

            showComponent() {
                this.shadowRoot.host.style.visibility = "visible";
            }

            hideComponent() {
                this.shadowRoot.host.style.visibility = "hidden";
            }

            i18n(presenter, key) {
                return presenter ? presenter.messages()[key]() : "";
            }

            icon(name) {
                return "fa fa-" + name;
            }

        }

        /**
         * Singleton per window/document, registers itself as window.openremote.INSTANCE.
         */
        class OpenRemoteApp extends Polymer.Element {

            static get is() {
                return "or-app";
            }

            static get properties() {
                return {
                    /**
                     * True if this app should enforce an authenticated user.
                     */
                    login: Boolean,

                    /**
                     * Name of the OpenRemote tenant realm this app wants to connect to
                     * and possibly login and authenticate with.
                     */
                    tenantRealm: {
                        type: String,
                        notify: true,
                        reflectToAttribute: true
                    },

                    /**
                     * Details of the tenant, available when authenticated and ready.
                     */
                    tenant: Object,

                    /**
                     * Whether the user is authenticated.
                     */
                    authenticated: {
                        type: Boolean,
                        notify: true,
                        reflectToAttribute: true,
                        observer: "onAuthenticated"
                    },

                    /**
                     * Name of the OpenRemote user to authenticate, available for two-way binding.
                     */
                    user: {
                        type: String,
                        notify: true,
                        reflectToAttribute: true
                    },

                    /**
                     * The REST HTTP request service.
                     */
                    requestService: {
                        type: Object
                    },

                    /**
                     *  The WebSocket connection to the event service.
                     */
                    webSocket: Object,

                    /**
                     * CONNECTED, DISCONNECTED, available for two-way binding.
                     */
                    status: {
                        type: String,
                        notify: true,
                        reflectToAttribute: true,
                        value: () => {
                            return "DISCONNECTED";
                        }
                    },

                    /**
                     * The current error state, if any.
                     */
                    error: {
                        type: String,
                        observer: "onAppError"
                    },

                    /**
                     * The message that should be shown to the user, before the error state.
                     */
                    defaultErrorMessage: {
                        type: String,
                        value: function () {
                            return "Service not available or application error, please try again later.";
                        }
                    },

                    /**
                     * Produces promises to load JS, CSS, HTML, IMG resources.
                     */
                    load: {
                        type: Object,
                        value: function () {
                            function _load(tag, rel) {
                                return function (url) {
                                    return new Promise(function (resolve, reject) {
                                        var element = window.document.createElement(tag);
                                        // Append loading tags to the body
                                        var parent = 'body';
                                        var attr = 'src';

                                        // Important success and error for the promise
                                        element.onload = function () {
                                            resolve(url);
                                        };
                                        element.onerror = function () {
                                            reject("Loading failed as '" + tag + "': " + url);
                                        };

                                        switch (tag) {
                                            case 'script':
                                                element.async = false;
                                                break;
                                            case 'link':
                                                element.rel = rel;
                                                attr = 'href';
                                                break;
                                        }

                                        element[attr] = url;
                                        window.document[parent].appendChild(element);
                                    });
                                };
                            }

                            return {
                                css: _load("link", "stylesheet"),
                                import: _load("link", "import"),
                                js: _load("script"),
                                img: _load("img")
                            }
                        }
                    }
                };
            }

            constructor() {
                super();

                // Hack the custom-style element into <head>
                let customStyle = document.createElement("custom-style");
                let style = document.createElement("style");
                style.setAttribute("include", "or-style");
                customStyle.appendChild(style);
                document.head.appendChild(customStyle);
            }

            ready() {
                super.ready();

                // This is a singleton for the window/main document
                if (window.openremote && window.openremote.INSTANCE) {
                    this.set("error", "An instance of &lt;or-app> is already registered on this window, please use only one per document.")
                    return;
                }
                // Register this as constant on window for GWT and others to access
                console.debug("Registering as window.openremote.INSTANCE");
                window.openremote = {INSTANCE: this};

                // The app should flex and its children should be in a flexbox vertical layout
                this.shadowRoot.host.classList.add("flex", "layout", "vertical");

                if (this.login) {
                    this.getSecurity().set("shellNative", this.$.shellNative);
                    this.getSecurity().startAuthentication();
                } else {
                    console.debug("No authentication required");
                    this.initialize();
                }
            }

            onAuthenticated(authenticated) {
                if (authenticated) {
                    console.debug("User authenticated: " + this.user);
                    this.initialize();
                }
            }

            logout() {
                if (this.getSecurity()) {
                    this.getSecurity().logout();
                }
            }

            initialize() {
                // This event is usually used to load other application resources which are not components, from the main document
                console.log("Application init, loading components");
                window.dispatchEvent(new CustomEvent("AppInit", {detail: {app: this}}));

                // Load service-generated REST API and GWT jsinterop components, in that order
                this.load.js("/jsapi")
                    .then(() => {
                        // We must set a base for jsinterop components or the GWT module loader will not be able to find
                        // it on Firefox/Safari, for some reason it uses a data URI to load the nocache.js, which then
                        // doesn't have a base for the next loading stage...
                        let baseUrlMeta = document.createElement("meta");
                        baseUrlMeta.setAttribute("name", "gwt:property");
                        baseUrlMeta.setAttribute("content", "baseUrl=/static/gwt/App/");
                        document.head.appendChild(baseUrlMeta);

                        // When this is done, it will fire AppLoaded on window
                        return this.load.js("/static/gwt/App/App.nocache.js")
                    })
                    .catch((e) => {
                        this.set("error", e);
                    });
            }

            onAppError(error) {
                console.error("Application error, disabling app: " + error);

                // Remove all slotted children, effectively disabling the app
                this.$.slot.assignedNodes({flatten: false}).forEach((node) => {
                    node.parentElement.removeChild(node);
                })

                // Hide the slots
                this.$.slots.style.display = "none";

                // Disable login/token refresh
                this.set("login", false);

                // Show the document body
                window.document.body.style.visibility = "visible";
            }

            showApp() {
                console.debug("Showing application");

                // The slotted children are hidden by default (this will set display: flex)
                this.$.slots.style.display = "inherit";

                // Safari bug, this will trigger another repaint, the first stops in some weird half-rendered state
                this.$.slots.style.webkitTransform = 'scale(1)';

                // Show the document body as late as possible, this hides the application
                // of custom-style, which flickers in Firefox
                window.document.body.style.visibility = "visible";
            }

            registerWidgetStyle() {
                openremote.WIDGET_STYLE = new openremote.style.WidgetStyle();
            }

            getSecurity() {
                return this.$.appSecurity;
            }

            registerRequestService() {
                let requestService = new openremote.REST.RequestService(
                    (requestParams, onComplete) => {
                        this.getSecurity().authorizeRequestParams(requestParams, onComplete);
                    },
                    (constraintViolationReportJson) => {
                        // TODO Anything else for constraint violation handling?
                        return JSON.parse(constraintViolationReportJson);
                    }
                    // TODO We should give a default error handler to RequestService
                );

                requestService.configure(this.tenantRealm);

                this.set("requestService", requestService);
            }

            connectEventService() {
                // Only authenticated apps can connect to the event service
                if (!this.login) {
                    return;
                }

                let serviceUrl = ("https:" === location.protocol ? "wss" : "ws") + "://" + location.hostname + ":" + location.port + "/websocket/events";
                this.getSecurity().authorizeUrl(serviceUrl, (authenticatedServiceUrl) => {

                    this.webSocket = new WebSocket(authenticatedServiceUrl);

                    this.webSocket.onopen = () => {
                        console.log("Connected to event service: " + serviceUrl);
                        this.set("status", "CONNECTED");
                    };

                    this.webSocket.onerror = () => {
                        this.set("webSocket", undefined);
                        this.set("status", "DISCONNECTED");
                        this.set("error", "Error connecting to event service: " + serviceUrl);
                    };

                    this.webSocket.onclose = (e) => {
                        this.set("webSocket", undefined);
                        this.set("status", "DISCONNECTED");
                        if (!this.error) {
                            if (e.code === 1001) {
                                this.set("error", "Server closed connection to event service: " + serviceUrl);
                            } else {
                                let msg = e.reason ? e.reason : serviceUrl;
                                this.set("error", "Event service connection was closed (clean: " + e.wasClean + ", code: " + e.code + "): " + msg);
                            }
                        }
                    };

                    this.webSocket.onmessage = (e) => {
                        // TODO Implement more
                        console.log("### RECEIVED EVENT SERVICE MESSAGE");
                        console.dir(e);
                    };
                });
            }

            loadTenantDetails(onComplete) {
                if (!this.login) {
                    onComplete();
                    return;
                }
                this.requestService.sendAndReturn(
                    (requestParams) => {
                        openremote.REST.TenantResource.get(requestParams, this.tenantRealm);
                    },
                    200,
                    (response) => {
                        this.set("tenant", response);
                        onComplete();
                    },
                    (exception) => {
                        // TODO Exception handler, or see above for default error handler in RequestService
                        console.log("### GOT EXCEPTION");
                        console.dir(exception);
                    }
                );
            }
        }

        // Bit of a hack, we must detect if GWT superdev compilation failed, then show the
        // document (without this, you won't see the failure message written by GWT dev mode
        // into the main doc)
        window.checkGwtSuperDevCompilationFailureInterval = window.setInterval(function() {
            if (document.querySelectorAll("a[target='gwt_dev_mode_log']").length > 0) {
                window.document.body.style.visibility = "visible";
            }
        }, 100);

        // Upgrade immediately, so you can't use jsinterop in this class!
        customElements.define(OpenRemoteApp.is, OpenRemoteApp);

        // This is fired after jsinterop components are loaded/started, finalize initialization
        window.addEventListener('AppLoaded', function () {

            window.clearInterval(window.checkGwtSuperDevCompilationFailureInterval);

            openremote.INSTANCE.registerRequestService();
            openremote.INSTANCE.registerWidgetStyle();

            openremote.INSTANCE.connectEventService();

            // Load the authenticated tenant details
            openremote.INSTANCE.loadTenantDetails(() => {

                // Check if there was a problem
                if (!openremote.INSTANCE.error) {
                    // If not, any other code can run and we are ready
                    dispatchEvent(new CustomEvent("AppReady", {detail: {app: openremote.INSTANCE}}));
                }

                // Now show the app/document body
                openremote.INSTANCE.showApp();
            })
        });

        // Elements which depend on jsinterop components must be initialized at the right time
        function defineAppElement(element, is, ...interopNames) {
            // TODO We could do this better, with a single listener that handles all elements

            // This is fired after authentication or when no authentication is needed, before the
            // jsinterop components are loaded. Here we register types defined in JS so they are
            // available when jsinterop components are loaded/started.
            window.addEventListener('AppInit', function () {
                console.log("Setting type in global scope: " + is);
                // Sets openremote.foo.bar.MyType = element so we can have the type in GWT jsinterop
                let x = openremote;
                for (let i = 0; i < interopNames.length; i++) {
                    let name = interopNames[i];
                    if (!x[name]) {
                        x[name] = i === interopNames.length - 1 ? element : {}
                    }
                    x = x[name];
                }
            });

            // This is fired after jsinterop components are loaded/started and after we have done any other
            // initialization (see above). Now the actual web component elements can be defined/upgraded,
            // this is when component constructors etc. lifecycle starts
            window.addEventListener('AppReady', function () {
                console.log("Upgrading element: " + is);
                customElements.define(is, element);
            });
        }
    </script>

</dom-module>