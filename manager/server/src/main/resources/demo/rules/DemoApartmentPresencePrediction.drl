package org.openremote.test.rules;

import org.openremote.model.*;
import org.openremote.model.asset.*
import elemental.json.Json;

global java.util.logging.Logger LOG;
global org.openremote.model.rules.Assets assets;

/*
New:

    // ROOM
    presenceDetected                    // true/false
    presenceDetectedInteger             // 1 on motion sense, 0 after 2 seconds. This behavior models typical PIR sensor
    lastPresenceDetectedTimeStamp       // Unix timestamp milliseconds

    // RESIDENCE
    selfLearning                        // true/false
    vacationDays                        // 0..123

    homeSceneStartMonday                // "17:30:00"
    homeSceneStartTuesday               // "17:45:00"
    ...
    awaySceneStartMonday                // "08:30:00"
    awaySceneStartTuesday               // "08:30:00"

    rule "..."
    when
        $dayOfWeek : util.formatDate("DAY_OF_WEEK", drools.clock.currentTime)
        AssetState(type == RESIDENCE, attributeName matches "homeSceneStart" + $dayOfWeek, valueChanged)
    then
        ...
    end

Old:

    presenceDetected                    // "on"
    presenceDetectedInteger             // 0, 1
    PRESENCE_LAST_DETECTED_TIME         // "-", hh:mm
    presenceDetectedUI                  // "Yes"/"No", Latches for 15mins; translates to somebody/nobody is in the office

    VACATION_DAYS                       // "0"

    UI_ESTIMATED_TIME_ARRIVAL           // This is today
    UI_ESTIMATED_TIME_DEPARTURE         // This is today
    UI_ESTIMATED_TIME_ARRIVAL.mon       // "9:00"
    UI_ESTIMATED_TIME_DEPARTURE.mon     // "17:00"
    UI_ESTIMATED_TIME_ARRIVAL.tue       // "9:00"
    UI_ESTIMATED_TIME_DEPARTURE.tue     // "17:00"
    UI_ESTIMATED_TIME_ARRIVAL.wed       // "9:00"
    UI_ESTIMATED_TIME_DEPARTURE.wed     // "17:00"
    ...

    ACTUAL_TIME_ARRIVAL                 // "-"
    ACTUAL_TIME_DEPARTURE               // "-"

    currentScene                          // "-", Possible values are "-", "Departure", "Arrive"
                                        // in blok61 it is "home", "away", "evening", "night"
*/


// ##########################################################################################################

// This rule converts any manufacturer dependent movement sensor into standardized PIR behaviour.
// Here emulate PIR from motionCounter by Enervalis
rule "person sense"
when
    AssetEvent(type == AssetType.ROOM, attributeName == "motionCounter", oldValue.asNumber < value.asNumber)
    AssetEvent($id: id, type == AssetType.ROOM, attributeName=="presenceDetectedInteger", value.asNumber!=1)
then
    LOG.info("@"+(new java.util.Date(drools.getWorkingMemory().getSessionClock().getCurrentTime())).toString());
    assets.dispatch( new AttributeEvent($id, "lastPresenceDetectedTimeStamp", Json .create(1)) );
end

// This rule models monostable PIR sensor behaviour, which goes to off state after 2s timeout
rule "no person sense"
    timer(int: 2s)
when
    AssetEvent(type == AssetType.ROOM, attributeName == "motionCounter", oldValue.asNumber < value.asNumber)
    AssetEvent($id: id, type == AssetType.ROOM, $s:attributeName=="presenceDetectedInteger", value.asNumber!=0)
then
    LOG.info("@"+(new java.util.Date(drools.getWorkingMemory().getSessionClock().getCurrentTime())).toString());
    assets.dispatch( new AttributeEvent($id, "lastPresenceDetectedTimeStamp", Json .create(0)) );
end

// Fetch last time when presence was detected. This time is used for period window adjustment.
rule "last move sense timestamp fetch"
when
    AssetEvent($id: id, type == AssetType.ROOM, attributeName=="presenceDetectedInteger", value.asNumber==1, valueChanged)
then
    // commands.execute("PRESENCE_LAST_DETECTED_TIME", $h.toString());
    long currentTime = drools.getWorkingMemory().getSessionClock().getCurrentTime();
    LOG.info("Move sense on "+$id+" @"+(new java.util.Date(currentTime)).toString() );
    assets.dispatch(
            // we want that this time stamp is persistent in memory because periods are quite long and it
            // is likely that a rule engine can restart in this time. Experience learns that this can
            // disturb the prediction time.
            new AttributeEvent($id, "lastPresenceDetectedTimeStamp", Json .create(currentTime))
    );
end

// Set the presence state which was previously used in the UI "Somebody is in the office"
rule "Presence"
when
    AssetEvent(type == AssetType.ROOM, $s:attributeName=="presenceDetectedInteger", value.asNumber==1)
    AssetState(type == AssetType.RESIDENCE, attributeName=="currentScene", value=="Departure") // within expected attendance schedule
    AssetState($id: id, type == AssetType.RESIDENCE, attributeName=="presenceDetectedUI", value.asString!="Yes")
then
    assets.dispatch( new AttributeEvent($id, "presenceDetectedUI", Json .create("Yes")) );
end

rule "Absence after 15 min"
    timer(int: 15m)
when
    AssetEvent($id: id, type == AssetType.ROOM, $s:attributeName=="presenceDetectedInteger", value.asNumber==0)
then
    assets.dispatch( new AttributeEvent($id, "presenceDetectedUI", Json .create("No")) );
end

// ##########################################################################################################

/*
rule "Move ETA to ET at midnight"
when
  SensorState(attributeName=="TIME_DAY_NAME_IN_WEEK", $e:value)
  SensorState(attributeName=="TIME_HH:MM:SS",$h:value,eval(util.parseTimestamp(value) >= util.parseTimestamp("00:02"))) // Wait 2 minutes to be sure that $e is OK
  SensorState(attributeName matches ("UI_ESTIMATED_TIME_ARRIVAL."+$e), eval(util.parseTimestamp(value) > util.parseTimestamp($h)), $va:value)
  SensorState(attributeName matches ("UI_ESTIMATED_TIME_DEPARTURE."+$e), $vd: value)
  SensorState(attributeName=="currentScene", value=="-")
  SensorState(attributeName=="VACATION_DAYS", eval(Integer.parseInt(value.toString())==0))
then
  commands.execute("UI_ESTIMATED_TIME_ARRIVAL", $va.toString());
  commands.execute("UI_ESTIMATED_TIME_DEPARTURE", $vd.toString());
  commands.execute("currentScene", "Arrive");
end

rule "Move ETA ETD for current day"
when
  SensorState(attributeName=="TIME_DAY_NAME_IN_WEEK", $e:value)
  SensorState(attributeName matches ("UI_ESTIMATED_TIME_ARRIVAL."+$e), $va:value)
  SensorState(attributeName matches ("UI_ESTIMATED_TIME_DEPARTURE."+$e), $vd: value)
then
  commands.execute("UI_ESTIMATED_TIME_ARRIVAL", $va.toString());
  commands.execute("UI_ESTIMATED_TIME_DEPARTURE", $vd.toString());
end

rule "reset ACTUAL_TIME_ARRIVAL"
when
  SensorState(attributeName=="currentScene", value=="Arrive")
then
  commands.execute("ACTUAL_TIME_ARRIVAL","-");
end

rule "reset ACTUAL_TIME_DEPARTURE"
when
  SensorState(attributeName=="ACTUAL_TIME_ARRIVAL",value=="-")
then
  commands.execute("ACTUAL_TIME_DEPARTURE","-");
end

rule "reset action at midnight"
when
  SensorState(attributeName=="TIME_HH:MM:SS", value!="N/A", eval(value.toString().substring(0,5).equals("00:00"))) // more reliable than timer(cron: )
then
  commands.execute("currentScene", "-");
end

rule "Move ETD to ET at arrive init"
// This one is needed for cases when system is restart after arrive time
when
  SensorState(attributeName=="TIME_DAY_NAME_IN_WEEK",$e:value)
  SensorState(attributeName=="TIME_HH:MM:SS",$h:value)
  SensorState(attributeName matches ("UI_ESTIMATED_TIME_ARRIVAL."+$e), eval(util.parseTimestamp(value) <= util.parseTimestamp($h)), eval(value.toString().length()==5))
  SensorState(attributeName matches ("UI_ESTIMATED_TIME_DEPARTURE."+$e), $vd:value, eval(value.toString().length()==5))
//  SensorState(attributeName=="currentScene", value=="-")
then
   commands.execute("UI_ESTIMATED_TIME_DEPARTURE", $vd.toString());
   commands.execute("currentScene", "Departure");
end

rule "Move ETD to ET at arrive"
when
  SensorState(attributeName=="TIME_DAY_NAME_IN_WEEK",$e:value)
  SensorState(attributeName=="TIME_HH:MM:SS",$h:value)
  SensorState(attributeName=="currentScene", value=="Arrive")
  SensorState(attributeName matches ("UI_ESTIMATED_TIME_DEPARTURE."+$e), $vd:value)
  SensorState(attributeName=="UI_ESTIMATED_TIME_ARRIVAL", value != "-", value != ":--", value != "status")
  SensorState(attributeName=="UI_ESTIMATED_TIME_ARRIVAL", eval(util.parseTimestamp(value) < util.parseTimestamp($h)))
  SensorState(attributeName=="VACATION_DAYS", eval(Integer.parseInt(value.toString())==0))
then
   commands.execute("currentScene", "Departure");
end

rule "fetch actual arrival time"
when
  SensorState(attributeName=="TIME_HH:MM:SS", $h:value)
  SensorState(attributeName=="ACTUAL_TIME_ARRIVAL", value == "-")
  SensorState(attributeName=="currentScene", value=="Departure")
    AssetEvent($id: id, type == AssetType.ROOM, $s:attributeName=="presenceDetectedInteger", value.asNumber==1)
then
  commands.execute("ACTUAL_TIME_ARRIVAL", $h.toString().substring(0,5));
end

rule "fetch earlier actual arrival time up to 30 min v02"
when
  SensorState(attributeName=="TIME_HH:MM:SS", $h:value, eval(util.parseTimestamp(value) >= util.parseTimestamp("04:30"))) // Earliest time of arrival is 4:30 AM
  SensorState(attributeName=="ACTUAL_TIME_ARRIVAL", value == "-")
  SensorState(attributeName=="currentScene", value=="Arrive")
    AssetEvent($id: id, type == AssetType.ROOM, $s:attributeName=="presenceDetectedInteger", value.asNumber==1)
  SensorState(attributeName=="UI_ESTIMATED_TIME_ARRIVAL", value != "-", value != ":--")
  SensorState(attributeName=="UI_ESTIMATED_TIME_ARRIVAL", eval(util.parseTimestamp(util.shiftTime(value,-30)) <= util.parseTimestamp($h)))
then
  commands.execute("ACTUAL_TIME_ARRIVAL", $h.toString().substring(0,5));
end

rule "Move - to ET at end of work"
timer(int: 1s) // avoid racing
when
  SensorState(attributeName=="TIME_HH:MM:SS",$h:value)
  SensorState(attributeName=="UI_ESTIMATED_TIME_DEPARTURE", value != "-", value != ":--")
  SensorState(attributeName=="UI_ESTIMATED_TIME_DEPARTURE", eval(util.parseTimestamp(value) < util.parseTimestamp($h)))
  SensorState(attributeName=="currentScene", value=="Departure")
then
  commands.execute("currentScene", "-");
end

rule "Move - to ET on vacation"
when
  SensorState(attributeName=="VACATION_DAYS", eval(Integer.parseInt(value.toString())>0))
then
  commands.execute("currentScene", "-");
end

rule "fetch actual departure time"
when
  SensorState(attributeName=="ACTUAL_TIME_ARRIVAL", value != "-")
  SensorState(attributeName=="ACTUAL_TIME_DEPARTURE", value == "-")
  SensorState(attributeName=="currentScene", value=="-")
  SensorState(attributeName=="PRESENCE_LAST_DETECTED_TIME", $v:value, eval(value.toString().length()>4))
then
  commands.execute("ACTUAL_TIME_DEPARTURE", $v.toString().substring(0,5));
  commands.execute("PRESENCE_LAST_DETECTED_TIME","-");
end

rule "fetch later departure time"
when
  SensorState(attributeName=="TIME_DAY_NAME_IN_WEEK",$e:value)
  SensorState(attributeName=="currentScene", value=="-")
  SensorState(attributeName matches ("UI_ESTIMATED_TIME_DEPARTURE."+$e), $vd:value)
  SensorState(attributeName=="ACTUAL_TIME_ARRIVAL", value != "-")
  SensorState(attributeName=="ACTUAL_TIME_DEPARTURE", value != "-")
  SensorState(attributeName=="PRESENCE_LAST_DETECTED_TIME", $v:value, eval(value.toString().length()>4),
                                              eval(util.parseTimestamp(value)<=util.parseTimestamp(util.shiftTime($vd,15))), // Till 15 min after scheduled departure
                                              eval(util.parseTimestamp(value)<=util.parseTimestamp("23:55"))) 	      	 // Till 23:55 - does	not wrap on midnight
  SensorState(attributeName=="VACATION_DAYS", eval(Integer.parseInt(value.toString())==0))
then
  commands.execute("ACTUAL_TIME_DEPARTURE", $v.toString().substring(0,5));
  commands.execute("PRESENCE_LAST_DETECTED_TIME","-");
end

*/

rule "adjust estimated times at next scene change"
when
    // Question: isn't AssetType checking relevant here? attributeName should be unique here or not?
    // We are in the self learning mode
    AssetState(attributeName == "selfLearning", type == AssetType.RESIDENCE, value.asBoolean)
    // We don't do this when on Vacations
    AssetState(attributeName == "vacationDays", type == AssetType.RESIDENCE, value.asNumber() > 0 )
    // Let's get in which scene are we now
    AssetState(attributeName == "currentScene", type == AssetType.RESIDENCE, $scene: value.asString )
    // For which day of week are we calculating this?
    $dayOfWeek : util.formatDate("DAY_OF_WEEK", drools.clock.currentTime)
    // Take the current value from the scene table
    AssetState($ref: attributeRef, type == AssetType.RESIDENCE, attributeName matches $scene + "SceneStart" + $dayOfWeek, $estimated_time: value.asNumber)
    // Now take the lastPresenceDetected (TODO here we will need probably a different logic dependent on scene)
    AssetState(attributeName == "lastPresenceDetected", type == AssetType.ROOM, $actual_time: value.asNumber > 0)
then
    // Take arbitrary coefficient which works good
    Double alpha = 2.0/(3+1); // 3 stays for 3 days exponential average
    // Calculate exponential moving average from the known formula
    long new_estimated_time = (long) (alpha*util.parseTimestamp($actual_time) + (1-alpha)*util.parseTimestamp($estimated_time));
    // Update value in the table
    assets.dispatch( new AttributeEvent($ref, Json.create(new_estimated_time)) );
end

// ##########################################################################################################



